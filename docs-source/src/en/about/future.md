# Looking for Future

> The future is bright and uncertain, let us look forward to the future development space of `YukiReflection`.

## Future Plans

> Features that `YukiReflection` may add later are included here.

### Automatically Generate Reflection Code

Use `stub` to create a Kotlin class, and declare the parameters in it, as well as its different states in each version.

For example, the Java class below is the target class we need to reflect.

> The following example

```java:no-line-numbers
package com.example.test;

public class MyClass {
    
    private String myField = "test";

    public MyClass() {
        //...
    }

    private String myMethod1(String var1, int var2) {
        //...
    }

    private void myMethod2() {
        //...
    }

    private void myMethod3(String var1) {
        //...
    }
}
```

Through the existing usage of the current API, this class can be called reflectively in the following way.

> The following example

```kotlin
classOf<MyClass>().buildOf().current {
    // Call myField
    val value = field { name = "myField" }.string()
    // Call myMethod1
    val methodValue = method { name = "myMethod1" }.string("test", 0)
    // Call myMethod2
    method { name = "myMethod2" }.call()
    // Call myMethod3
    method { name = "myMethod3" }.call("test")
}
```

The function to be implemented at present can be directly defined as the following Kotlin class using the reflection function.

> The following example

```kotlin
package com.example.test

@ReflectClass
class MyClass {

    @ReflectField
    val myField: String = fieldValueOf("none")

    @ReflectMethod
    fun myMethod1(var1: String, var2: Int): String = methodReturnValueOf("none")

    @ReflectMethod
    fun myMethod2() = MethodReturnType.Unit

    @ReflectMethod
    fun myMethod3(var1: String) = MethodReturnType.Unit
}
```

Then we can directly call this defined Kotlin class to implement the reflection function, and the API will automatically generate the reflection code according to the annotation.

> The following example

```kotlin
MyClass().also {
    // Call myField
    val value = it.myField
    // Call myMethod1
    val methodValue = it.myMethod1("test", 0)
    // Call myMethod2
    it.myMethod2()
    // Call myMethod3
    it.myMethod3("test")
}
```

::: tip

The above functions may change after the actual release, and the functions of the actual version shall prevail.

:::

### Automatically Generate Directly Called Class Objects

In Kotlin, the way to represent Java class objects is `YourObject::class.java`.

This writing method is usually very long and will be very unsightly when used extensively during reflection.

In the existing version, we have built-in commonly used `Class` objects, but this will increase the size of dependencies, and these objects may not be used in most cases.

For example, `StringClass`, `IntType`, etc., these objects are built in `YukiReflection`.

So we plan to add a function in the future, which can use `properties` to create a list of `Class` objects that need to be generated,
and generate these `Class` objects in sequence through the Gradle plugin.

`Class` objects of primitive types such as those mentioned above will still be built into `YukiReflection`,
and the remaining `Class` objects need to be defined by yourself.

The generated name specification is **Class Name + Class**.

In order to prevent package name conflicts, you can control the sub-package name of the generated `Class` object.

In the configuration file, you don't need to add `Class` as a suffix.

You can define the generated root package name in the Gradle plugin, which defaults to `com.highcapable.yukireflection.generated.classes`.

> The following example

```properties
# The most basic way to define is to write the name directly
# Will be generated to com.highcapable.yukireflection.generated.classes.BundleClass
android.os.Bundle=Bundle
# You can use the "." form in front to define the prefixed subpackage name
# For example, we want to define this class to the desired package name
# Will be generated to com.highcapable.yukireflection.generated.classes.myandroid.myos.BundleClass
android.os.Bundle=myandroid.myos.Bundle
# You can also not fill in the key value content, which will use the key value name
# as the defined package name and class name
# Will be generated to com.highcapable.yukireflection.generated.classes.android.os.BundleClass
android.os.Bundle
```

The approximate code form of the `Class` object generated by the above method is as follows.

```kotlin
package com.highcapable.yukireflection.generated.classes.android.os

// Used with default ClassLoader
val BundleClass: Class<*> = "android.os.Bundle".toClass()

// Used when ClassLoader is specified
fun BundleClass(loader: ClassLoader): Class<*> = "android.os.Bundle".toClass(loader)
```

Maybe this `Class` may not be obtained in some cases.

In this case, you can refer to the following configuration method.

> The following example

```properties
# Add "?" after the key value to define a nullable Class object
android.os.Bundle?
```

The approximate code form of the `Class` object generated by the above method is as follows.

```kotlin
package com.highcapable.yukireflection.generated.classes.android.os

// Used with default ClassLoader
val BundleClass: Class<*>? = "android.os.Bundle".toClassOrNull()

// Used when ClassLoader is specified
fun BundleClass(loader: ClassLoader): Class<*>? = "android.os.Bundle".toClassOrNull(loader)
```

If this `Class` object can be referenced by direct call, you can refer to the following configuration method at this time.

> The following example

```properties
# Add "!!" after the key value to define a Class object that can be called directly
android.os.Bundle!!
```

The approximate code form of the `Class` object generated by the above method is as follows.

```kotlin
package com.highcapable.yukireflection.generated.classes.android.os

import android.os.Bundle

// Used with default ClassLoader
val BundleClass: Class<Bundle> = classOf<Bundle>()

// Used when ClassLoader is specified
fun BundleClass(loader: ClassLoader): Class<Bundle> = classOf<Bundle>(loader)
```

With the generated `Class` object, we can happily use `YukiReflection` for reflection.

> The following example

```kotlin
method {
    name = "onCreate"
    param(BundleClass)
}
```

::: tip

The above functions may change after the actual release, and the functions of the actual version shall prevail.

:::